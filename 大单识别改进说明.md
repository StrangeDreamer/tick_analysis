# 大单识别逻辑改进说明

## 📊 改进概述

原方法只基于**成交量**和**75分位数**识别大单，存在以下问题：
1. 不同价格的股票，同样成交量代表不同资金量
2. 75分位数可能不够严格，误判较多
3. 单一阈值方法不够灵活

## 🎯 新增的6种识别方法

### 1. `volume` - 基于成交量（原方法）
- **原理**: 使用成交量的分位数和固定阈值
- **优点**: 简单直接
- **缺点**: 不考虑价格因素，不同价格股票可比性差
- **适用**: 价格相近的股票

```python
threshold = max(50000手, 75分位数)
权重 = min(3.0, (成交量/阈值)^1.2)
```

### 2. `amount` - 基于成交额（推荐⭐）
- **原理**: 使用成交额（金额）而非成交量
- **优点**: 
  - 更科学，考虑价格因素
  - 不同价格股票可比性强
  - 更能反映真实资金流向
- **缺点**: 需要数据中有成交额字段
- **适用**: **通用推荐方法**

```python
threshold = max(50万元, 90分位数)  # 默认90分位更严格
权重 = min(3.0, (成交额/阈值)^1.2)
```

### 3. `iqr` - IQR四分位距方法
- **原理**: 使用统计学IQR方法识别异常值
- **优点**: 
  - 统计上更稳健
  - 对异常值不敏感
  - 自动适应数据分布
- **适用**: 数据分布不均匀的情况

```python
Q1 = 25分位数
Q3 = 75分位数
IQR = Q3 - Q1
threshold = Q3 + 1.5 * IQR  # 1.5倍IQR为异常值
```

### 4. `zscore` - Z-score方法
- **原理**: 基于均值和标准差识别异常值
- **优点**: 
  - 基于正态分布假设
  - 标准化处理
- **缺点**: 对非正态分布数据效果一般
- **适用**: 数据接近正态分布时

```python
mean = 均值
std = 标准差
threshold = mean + 2.0 * std  # 2倍标准差
```

### 5. `hybrid` - 混合方法（最推荐⭐⭐）
- **原理**: 结合成交额、IQR和分位数
- **优点**: 
  - **最科学的方法**
  - 多重验证，减少误判
  - 自动适应不同股票特征
  - 兼顾绝对阈值和相对阈值
- **适用**: **所有场景，默认方法**

```python
# 计算多个阈值
iqr_threshold = Q3 + 1.5 * IQR
percentile_threshold = 90分位数
base_threshold = 50万元

# 取最大值，确保识别真正的大单
threshold = max(iqr_threshold, percentile_threshold, base_threshold)
```

### 6. `tiered` - 分档加权方法
- **原理**: 将交易分为小单、中单、大单、超大单
- **优点**: 
  - 更细粒度
  - 不同档位不同权重
  - 更符合实际交易习惯
- **适用**: 需要精细分析的场景

```python
小单(≤25分位): 权重 1.0
中单(25-50分位): 权重 1.1
中大单(50-75分位): 权重 1.3
大单(75-90分位): 权重 1.8
超大单(>90分位): 权重 2.5-3.0（动态）
```

## ⚙️ 配置参数

在 `__init__` 方法中配置：

```python
# 选择识别方法
self.large_trade_method = 'hybrid'  # 可选: 'volume', 'amount', 'iqr', 'zscore', 'hybrid', 'tiered'

# 基础阈值
self.large_trade_volume_threshold = 50000  # 成交量阈值（手）
self.large_trade_amount_threshold = 500000  # 成交额阈值（元）

# 分位数设置
self.large_trade_percentile = 90  # 分位数阈值（默认90，更严格）

# IQR方法参数
self.large_trade_iqr_multiplier = 1.5  # IQR倍数（1.5为标准异常值）

# Z-score方法参数
self.large_trade_zscore_threshold = 2.0  # Z-score阈值（2倍标准差）

# 权重计算参数
self.large_trade_weight_power = 1.2  # 权重幂次
self.large_trade_max_weight = 3.0  # 最大权重倍数
```

## 📈 方法对比

| 方法 | 科学性 | 适应性 | 准确性 | 推荐度 |
|------|--------|--------|--------|--------|
| volume | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ |
| amount | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| iqr | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| zscore | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **hybrid** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| tiered | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

## 🚀 使用建议

### 默认推荐配置
```python
self.large_trade_method = 'hybrid'  # 混合方法
self.large_trade_percentile = 90  # 90分位更严格
self.large_trade_amount_threshold = 500000  # 50万基础阈值
```

### 不同场景推荐

1. **通用场景**（推荐）:
   ```python
   method = 'hybrid'
   ```

2. **需要更严格识别**:
   ```python
   method = 'hybrid'
   percentile = 95  # 提高到95分位
   ```

3. **数据分布不均匀**:
   ```python
   method = 'iqr'
   ```

4. **需要精细分析**:
   ```python
   method = 'tiered'
   ```

5. **价格相近的股票**:
   ```python
   method = 'amount'  # 或保持 'hybrid'
   ```

## 🔍 改进效果

### 原方法问题
- ❌ 只考虑成交量，忽略价格
- ❌ 75分位可能不够严格
- ❌ 单一阈值，不够灵活

### 改进后优势
- ✅ 基于成交额，更科学
- ✅ 多重验证，减少误判
- ✅ 自动适应不同股票特征
- ✅ 6种方法可选，灵活配置
- ✅ 分档加权，更精细

## 📝 代码示例

```python
# 在初始化时设置
quant = QuantAnalysis()
quant.large_trade_method = 'hybrid'  # 使用混合方法
quant.large_trade_percentile = 90  # 90分位
quant.large_trade_amount_threshold = 500000  # 50万

# 分析时会自动使用新方法
result = quant.analyze_trade_direction(tick_df, symbol)
# result['large_trade_threshold'] 会显示使用的阈值
```

## 🎓 技术说明

### 为什么成交额比成交量更科学？

**例子**：
- 股票A：价格10元，成交量10000手 = 成交额1000万元
- 股票B：价格100元，成交量10000手 = 成交额10000万元

同样成交量，但股票B的资金量是股票A的10倍！使用成交额能更准确反映资金流向。

### IQR方法为什么更稳健？

IQR（四分位距）方法不依赖数据的均值和标准差，对异常值不敏感，更适合金融数据（通常有长尾分布）。

### 混合方法为什么最好？

混合方法结合了：
1. **绝对阈值**（50万）：确保识别真正的大单
2. **相对阈值**（90分位）：适应不同股票的交易规模
3. **统计方法**（IQR）：自动识别异常值

三重验证，既准确又灵活！

